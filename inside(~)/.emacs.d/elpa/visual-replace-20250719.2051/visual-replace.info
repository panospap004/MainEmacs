This is visual-replace.info, produced by makeinfo version 6.8 from
visual-replace.texi.

     Visual-Replace

     Stephane Zermatten

     Copyright © 2020-2024, Stephane Zermatten

INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* visual-replace: (visual-replace.info). A nicer interface for string-replace and query-replace
                        that supports previews.
END-INFO-DIR-ENTRY


   Generated by Sphinx.


File: visual-replace.info,  Node: Top,  Next: Comparison with other packages,  Up: (dir)

Visual Replace
**************

     Visual-Replace

     Stephane Zermatten

     Copyright © 2020-2024, Stephane Zermatten

Visual Replace provides a nicer interface to Query-Replace(1) than the
built-in one.

The main improvements are:

        * The prompt of Visual Replace includes both the text to be
          replaced and the replacement.  This makes it easier to craft
          possibly complex regular expression search and replace.

        * You can see the matches and how they’re going to be modified
          as you edit the command arguments.

        * To help craft the search string and its replacement, you can
          navigate between matches with the arrow keys and optionally
          see the number of matches in the prompt.

        * You can apply only some replacements, selectively, using
          keyboard shortcuts, or by clicking on the preview.

        * You can modify the scope and type of the search-and-replace
          command, to the full buffer, the region or everything after
          the point.

Visual Replace is just an interface.  The actual replacements are always
done by the standard Emacs commands.

* Menu:

* Comparison with other packages::
* Contents::
* Index::

   ---------- Footnotes ----------

   (1) 
https://www.gnu.org/software/emacs/manual/html_node/emacs/Query-Replace.html


File: visual-replace.info,  Node: Comparison with other packages,  Next: Contents,  Prev: Top,  Up: Top

1 Comparison with other packages
********************************

What seems to be unique about Visual Replace is that the thing to be
replaced and the replacement at the same time are modified at the same
time.  The other packages I’ve found make it a 2-step process in most
cases.

visual-regexp(1) also supports a preview, but uses its own
search-and-replace mechanism and only supports a regexp mode.

anzu(2) is otherwise very similar to visual-replace.  It was abandoned
for a long time, but has been recently taken up by a new maintainer.

   ---------- Footnotes ----------

   (1) https://github.com/benma/visual-regexp.el

   (2) https://github.com/emacsorphanage/anzu


File: visual-replace.info,  Node: Contents,  Next: Index,  Prev: Comparison with other packages,  Up: Top

2 Contents
**********

* Menu:

* Installation::
* Usage::
* API::
* Contributing::


File: visual-replace.info,  Node: Installation,  Next: Usage,  Up: Contents

2.1 Installation
================

Install Visual Replace:

   - from MELPA or MELPA Stable(1) using ‘M-x package-install
     visual-replace’

   - on a recent version of Emacs (29 or later), from the github
     repository by doing ‘M-x package-vc-install
     https://github.com/szermatt/visual-replace’

   - from source, using an alternative package managers, such as
     straight(2), shown here:

          (use-package visual-replace
            :straight (:type git :repo "https://github.com/szermatt/visual-replace.git"))

   - the old-fashioned way, copying visual-replace.el(3) into your
     ‘.emacs.d’ directory.

Visual Replace requires Emacs 26.1 or later.

   ---------- Footnotes ----------

   (1) https://melpa.org/#/getting-started

   (2) https://github.com/radian-software/straight.el

   (3) 
https://raw.githubusercontent.com/szermatt/visual-replace/refs/heads/master/visual-replace.el


File: visual-replace.info,  Node: Usage,  Next: API,  Prev: Installation,  Up: Contents

2.2 Usage
=========

* Menu:

* Calling Visual Replace::
* Visual Replace Mode::
* Yank and Pop::
* Single replacements::
* Customization::
* Face Customization::
* Commands::
* Keymaps::
* Hooks::
* Limitations::


File: visual-replace.info,  Node: Calling Visual Replace,  Next: Visual Replace Mode,  Up: Usage

2.2.1 Calling Visual Replace
----------------------------

Visual Replace needs to be bound to a key to be of any use.

Choose a reasonably short key combination and bind ‘visual-replace’ to
it.  It should be reasonably short, because ‘visual-replace’, by
default, uses the key combination it’s called with as prefix for the
commands available in the minibuffer.

Here’s an example that uses ‘M-%’ as key combination, since this is
bound by default to ‘query-replace’, which Visual Replace then, well,
replaces:

     (use-package visual-replace
       :defer t
       :bind (("M-%" . visual-replace)
              :map isearch-mode-map
              ("M-%" . visual-replace-from-isearch))
       :config
       (define-key visual-replace-mode-map (kbd "M-%")
                   visual-replace-secondary-mode-map))

The above example also binds ‘M-%’ in isearch, so you can just switch
from isearch to Visual Replace.  Additionally, while Visual Replace is
active ‘M-%’ is the prefix for Visual Replace commands, so, for example,
toggling regexp mode on and off is ‘M-% r’.

An alternative, which you might prefer to try things out, is to replace
‘query-replace’ and others with Visual Replace.  This then uses whatever
shortcut you’ve already installed.

     (use-package visual-replace
       :defer nil
       :config
       (visual-replace-global-mode 1))

Once this is done, launch ‘visual-replace’ with the keybinding you
chose.


File: visual-replace.info,  Node: Visual Replace Mode,  Next: Yank and Pop,  Prev: Calling Visual Replace,  Up: Usage

2.2.2 Visual Replace Mode
-------------------------

When Visual Replace is running, you’ll see, something like the following
in the minibuffer ‘Replace from point […]: ┃ →’.  The text before the
arrow is the text to replace and the text after the arrow is the
replacement.  You can navigate back and forth with ‘TAB’ or by moving
the cursor.

See also the example below.

[Screen grab showing Visual Replace in action]

Once both fields are filled, press ‘RET’ to execute the replacement.

When there’s no replacement ‘RET’ instead moves the cursor to the
replacement, in case muscle memory kicks in and you type: ‘text to
replace’ ‘RET’ ‘replacement’ ‘RET’.  That’ll work.

The prompt also displays the mode of replacement:

   * ‘text’ → ‘replacement’ executes ‘string-replace’

   * ‘text’ →?  ‘replacement’ executes ‘query-replace’

   * ‘text’ →.* ‘replacement’ executes ‘replace-regexp’

   * ‘text’ →?.* ‘replacement’ executes ‘query-replace-regexp’

After typing a few characters of the string to match ‘visual-replace’
enters preview mode, and highlights the matches.  It also scrolls the
window to keep at least one example of matches visible.  You can also
press up and down to go through the matches.

In Visual Replace mode:

   * ‘TAB’ navigates between the text to replace and the replacement
     string

   * ‘RET’ switches to the replacement string, the first time, then
     executes the replacement

   * ‘M-% r’ toggles regexp mode on and off.  You know this mode is on
     when a ‘.*’ follows the arrow.

   * ‘M-% q’ toggles query mode one and off, that is, it toggles between
     calling ‘replace-string’ and ‘query-replace’.  You know this mode
     is on when a ‘?’ follows the arrow.  For an alternative way of
     replacing only some matches, see *note Single replacements: a.

   * ‘M-% SPC’ switches between different scopes: full buffer, from
     point, in region.  The scope is indicated in the prompt.
     Additionally, for from point and in region, the region is
     highlighted.

   * ‘M-% w’ toggle limiting search to whole words.  You know this mode
     is on when a ‘w’ follows the arrow.

   * ‘M-% c’ toggle case-fold.  You know this mode is on when a ‘c’
     follows the arrow.

   * ‘M-% s’ toggle lax whitespace.  You know this mode is on when ‘(lax
     ws)’ follows the arrow.

   * ‘M-% b’ toggle backward replace.  You know this mode is on when a
     ‘↩’ follows the arrow.  This only matters if query search mode

is on of when a replacement contains ‘\\#’.

   * ‘<up>’ and ‘<down>’ move the cursor to the next or previous match,
     scrolling if necessary.

   * ‘M-% a’ applies a single replacement, to the match right under the
     cursor or following the cursor, then move on to the next match.
     With a prefix argument N, apply N replacements.  See also *note
     Single replacements: a.

   * ‘M-% u’ calls ‘undo’ on the original buffer, to revert a previous
     replacement.  With a prefix argument N, repeat undo N times.

   * As usual, ‘C-p’ and ‘C-n’ go up and down the history, like on any
     prompt.

(Reminder: replace ‘M-%’ with the keyboard shortcut you chose.)

If you leave ‘visual-replace’ without confirming, with ‘C-g’, you can
continue where you left off next time by going up in the history.

See Search(1) in the Emacs manual for details of the different modes
listed above.

   ---------- Footnotes ----------

   (1) 
https://www.gnu.org/software/emacs/manual/html_node/emacs/Search.html


File: visual-replace.info,  Node: Yank and Pop,  Next: Single replacements,  Prev: Visual Replace Mode,  Up: Usage

2.2.3 Yank and Pop
------------------

Yank, usually bound to ‘C-y’, works differently in Visual Replace than
it does normally.  In Visual Replace mode, it calls
‘visual-replace-yank’.

   * In the search section, yanking copies text from the current buffer
     into the search section.  This avoids typing text when it’s right
     under the point.

     You can also move to a match with ‘<up>’ and ‘<down>’ to capture
     more text from the buffer.

   * In the replacement section, yanking copies text from the search
     section.  This avoids typing the search string again when you just
     want to make some small changes to it.

The normal yank can be executed by calling ‘yank-pop’, usually bound to
‘M-y’.

This can be configured by editing ‘visual-mode-map’.  For example, to
use the normal yank commands, you can do:

     (define-key visual-replace-mode-map [remap yank] nil)
     (define-key visual-replace-mode-map [remap yank-pop] nil)


File: visual-replace.info,  Node: Single replacements,  Next: Customization,  Prev: Yank and Pop,  Up: Usage

2.2.4 Single replacements
-------------------------

If you want to replace only ‘some’ matches within the scope, you can:

   * use the ‘query-replace’ UI to go through all matches using ‘M-% q’,
     then typing ‘RET’ to enter Query Replace mode.  ‘

   * in preview mode, click on the replacements you want to apply.  You
     can scroll the buffer as needed, normally or, from the minibuffer
     with ‘<up>’ and ‘<down>’.

   * navigate to the replacements you want to apply with ‘<up>’ and
     ‘<down>’, the call ‘M-% a’ to apply one replacement.

     On Emacs 29.1 or later, this enters a mode that allows applying
     replacement with ‘a’, the last part of the key sequence, and also
     moving through the matches with ‘<down>’ or ‘<up>’.  ‘u’ reverts
     the last replacement.


File: visual-replace.info,  Node: Customization,  Next: Face Customization,  Prev: Single replacements,  Up: Usage

2.2.5 Customization
-------------------

This section lists a few of the most interesting customization options
available in visual replace.  Call ‘M-x customize-group visual-replace’
to see all options.  For face customization, see the :ref‘next
section<faces>‘.

visual-replace-preview : customization option

     With this option enabled, Visual Replace highlights matches and
     offer a preview of their replacements.  This is enabled by default.

visual-replace-first-match : customization option

     With this option enabled, Visual Replace always tries to have at
     least one match visible in the preview, even if it means jumping to
     another section of the buffer.  This is enabled by default.

keep-initial-position : customization option

     With this option enabled, Visual Replace goes back to the point it
     was called from, even if the point was moved during preview, to
     display the first match, or manually with ‘<down>’ or ‘<up>’.

     Note that in the case where the point is moved during preview,
     Visual Replace sets a mark at the original location, to go back too
     if necessary.

visual-replace-display-total : customization option

     By default, in preview mode, visual Replace only searches for and
     display matches in the visible portions of the buffer.  With this
     option enabled, Visual Replace searches the whole buffer, in an
     idle timer, and displays the total number of matches in the prompt.

     When the point is on a match, the index of the match is also
     displayed, in front of the total.

     The total might be slow to update on large buffers or when using
     complicated regexps.

     This is not enabled by default.

visual-replace-initial-scope : customization option

     With this option set, the initial scope ignores the active region
     entirely and is always set to either “From Point” or “Full Buffer”.

     By default, the initial scope is:

             * the active region, if there is one

             * from point if ‘visual-replace-default-to-full-scope’ is
               nil, see below

             * the full buffer otherwise

visual-replace-default-full-scope : customization option

     With this option set, when no region is active, replacement applies
     by default to the full buffer, instead of to the region following
     the point.

visual-replace-defaults-hook : customization option

     To modify search and replace defaults, such as, for example, having
     searches default to regular expressions or search default to word
     mode, call the command that turns it on from this hook.  This is
     called when Visual Replace is started with no initial text, so
     these customizations won’t apply to ‘visual-replace-from-isearch’,
     for example.

visual-replace-minibuffer-mode-hook : customization option

     This hook is called when Visual Replace is started in the
     minibuffer.  It can be used to turn on query mode in all cases by
     registering the command ‘visual-replace-toggle-query’ in this hook.

     Rather than setting the as a customization, with ‘use-package’, you
     can force Visual Replace to call ‘query-replace’ by default with:

          (use-package visual-replace
            [...]
            :hook ((visual-replace-minibuffer-mode . visual-replace-toggle-query))

visual-replace-min-length : customization option

     This specifies the minimum number of characters that need to be
     typed before Visual Replace enters preview mode.

     Setting this too low might result in strange highlights happening
     when starting to type in the match string.


File: visual-replace.info,  Node: Face Customization,  Next: Commands,  Prev: Customization,  Up: Usage

2.2.6 Face Customization
------------------------

Visual Replace relies an a large number of faces to display things the
way they should be:

        * ‘visual-replace-match’, for matches with no replacement

        * ‘visual-replace-match-highlight’, for matches at point with no
          replacement

        * ‘visual-replace-replacement’, for match replacement

        * ‘visual-replace-replacement-highlight’, for match replacement,
          at point

        * ‘visual-replace-delete-match’, for text to be deleted

        * ‘visual-replace-delete-match-highlight’, for text to be
          deleted at point

        * ‘visual-replace-match-count’, for displaying the number of
          matches before the prompt

        * ‘visual-replace-separator’, for displaying the separator
          between the search and replacement strings in the prompt

        * ‘visual-replace-region’, for highlighting the area of the
          buffer to which search and replace apply

The defaults values for this faces attempt to reuse existing faces as
much as possible to try and look reasonable whatever the current Emacs
theme, but the result isn’t always too great.  In particular,
‘visual-replace-region’, which uses the same face as the region, is
typically too bright and in-your-face.  It should ideally use a fainter
color than the region, still visible, but not too different from the
normal background as to cause readability issues.

Therefore, it’s a good idea to configure the Visual Replace faces to
match your theme and preferences.

The sections below list my attempts at configuring Visual Replace for
the Modus themes(1), now installed in Emacs by default, and the Ef
themes(2), by the same author.  This should hopefully help you get
started.

The code snippets rely on ‘after-enable-theme-hook’ to detect theme
changes, from the Section 5.23 of the Emacs 29 Manual(3):

     (defun run-after-enable-theme-hook (&rest _args)
        "Run `after-enable-theme-hook'."
        (run-hooks 'after-enable-theme-hook))

     (advice-add 'enable-theme :after #'run-after-enable-theme-hook)

* Menu:

* Modus Themes::
* Ef Themes::

   ---------- Footnotes ----------

   (1) https://protesilaos.com/emacs/modus-themes

   (2) https://protesilaos.com/emacs/ef-themes

   (3) 
https://www.gnu.org/software/emacs/manual/html_node/modus-themes/A-theme_002dagnostic-hook-for-theme-loading.html


File: visual-replace.info,  Node: Modus Themes,  Next: Ef Themes,  Up: Face Customization

2.2.6.1 Modus Themes
....................

     (defun my-modus-themes-custom-faces ()
       (when (delq nil (mapcar (lambda (t) (string-prefix-p "modus-" (symbol-name t)))
                               custom-enabled-themes))
         (modus-themes-with-colors
           (custom-set-faces
            `(visual-replace-match-count ((t :inherit modus-themes-prompts)))
            `(visual-replace-separator ((t :inherit modus-themes-prompts)))
            `(visual-replace-match ((t :inherit modus-themes-search-success-lazy)))
            `(visual-replace-replacement ((t :background ,bg-diff-added :foreground ,fg-diff-added)))
            `(visual-replace-delete-match ((t :strike-through t :background ,bg-diff-removed :foreground ,fg-diff-removed)))
            `(visual-replace-match-highlight ((t  :inherit modus-themes-search-success)))
            `(visual-replace-delete-match-highlight ((t :strike-through t :background ,bg-diff-refine-removed :foreground ,fg-diff-refine-removed)))
            `(visual-replace-replacement-highlight ((t :background ,bg-diff-refine-added :foreground ,fg-diff-refine-added)))
            `(visual-replace-region ((t :background ,bg-special-faint-cold :extend t )))))))
     (add-hook 'after-enable-theme-hook #'my-modus-themes-custom-faces)


File: visual-replace.info,  Node: Ef Themes,  Prev: Modus Themes,  Up: Face Customization

2.2.6.2 Ef Themes
.................

      (defun my-ef-themes-custom-faces ()
       (when (delq nil (mapcar (lambda (t) (string-prefix-p "ef-" (symbol-name t)))
                               custom-enabled-themes))
         (ef-themes-with-colors
           (let ((bg-region-fainter (my-color-closer bg-region bg-main 0.3)))
             (custom-set-faces
              `(visual-replace-match-count ((,c :foreground ,prompt)))
              `(visual-replace-separator ((,c :foreground ,prompt)))
              `(visual-replace-match ((,c :background ,bg-search-lazy :foreground ,fg-intense)))
              `(visual-replace-replacement ((,c :background ,bg-added :foreground ,fg-added)))
              `(visual-replace-delete-match ((,c :strike-through t :background ,bg-removed-faint :foreground ,fg-removed)))
              `(visual-replace-match-highlight ((,c  :background ,bg-search-match :foreground ,fg-intense )))
              `(visual-replace-delete-match-highlight ((,c :strike-through t :background ,bg-removed-refine :foreground ,fg-intense)))
              `(visual-replace-replacement-highlight ((,c :background ,bg-added-refine :foreground ,fg-intense)))
              `(visual-replace-region ((,c :background ,bg-region-fainter :extend t ))))))))

       (defun my-color-closer (from to fraction)
       "Move FROM luminance closer to TO by the given FRACTION."
       (let* ((from-hsl (apply 'color-rgb-to-hsl (color-name-to-rgb from)))
              (to-hsl (apply 'color-rgb-to-hsl (color-name-to-rgb to))))
         (apply 'color-rgb-to-hex
                (color-hsl-to-rgb
                 (nth 0 from-hsl)
                 (nth 1 from-hsl)
                 (+ (nth 2 from-hsl) (* fraction (- (nth 2 to-hsl) (nth 2 from-hsl))))))))

     (add-hook 'after-enable-theme-hook #'my-ef-themes-custom-faces)


File: visual-replace.info,  Node: Commands,  Next: Keymaps,  Prev: Face Customization,  Up: Usage

2.2.7 Commands
--------------

visual-replace : command

     This is the main command that starts Visual Replace and then
     executes the search-and-replace.  It can replace ‘replace-string’,
     ‘query-replace’, ‘replace-regexp’ and ‘query-replace-regexp’.

visual-replace-thing-at-point : command

     This command starts a visual replace session with the symbol at
     point as text to replace.

visual-replace-selected : command

     This command starts with the text within the current active region
     as text to replace.

visual-replace-from-isearch : command

     This command switches from an active isearch session to
     ‘visual-replace’, keeping the current search text and settings,
     such as regexp mode.  This is meant to be called while isearch is
     in progress, and bound to ‘isearch-mode-map’.

The following commands are meant to be called while in Visual Replace
mode, from ‘visual-mode-map’.  By default, they’re bound in
‘visual-replace-secondary-mode-map’:

visual-replace-toggle-regexp : <prefix> r , command

     toggles regexp mode on and off.

visual-replace-toggle-scope : <prefix> SPC, command

     changes the scope of the search.

visual-replace-toggle-query : <prefix> q, command

     toggles the query mode on and off.

visual-replace-toggle-word : <prefix> w, command

     toggles the word mode on and off.

visual-replace-toggle-case-fold : <prefix> c, command

     toggles the case fold mode on and off.

visual-replace-toggle-backwards : <prefix> d, command

     toggles backward replacement on and off.

visual-replace-toggle-lax-ws : <prefix> s, command

     toggles the lax whitespace mode on and off.

visual-replace-next-match : <down>, command

     moves cursor to the next match

visual-replace-prev-match : <up>, command

     moves cursor to the previous match

visual-replace-apply-one : <prefix> a, command

     applies a single replacement, to the match at or after the cursor,
     then moves on to the next match.  With a prefix argument N, apply N
     replacements instead of just one.

     This command, used together with ‘visual-replace-next-match’ and
     ‘visual-replace-prev-match’ is in many cases functionally
     equivalent to using the query mode, but with a different interface
     that the possibility of changing the query as you go.

visual-replace-apply-one-repeat : <prefix> a, command

     on Emacs 29.1 and later, executes ‘visual-replace-apply-one’, then
     installs a transient map that allows:

        * repeating ‘visual-replace-apply-one’ by typing the last part
          of the key sequence used to call
          ‘visual-replace-apply-one-repeat’

        * skipping matches with ‘<down>’, which calls
          ‘visual-replace-next-match’

        * going up the match previews with ‘<up>’, which calls
          ‘visual-replace-prev-match’

        * undoing the last replacement with ‘u’

        * Typing anything else deactivates the transient map.

     The keybindings can be configured by modifying the map
     ‘visual-replace-transient-map’.

visual-replace-undo : <prefix> u, command

     reverts the last call to ‘visual-replace-apply-one’.  This just
     executes ‘undo’ in the original buffer.  With a prefix argument N,
     call undo N times instead of just one.


File: visual-replace.info,  Node: Keymaps,  Next: Hooks,  Prev: Commands,  Up: Usage

2.2.8 Keymaps
-------------

visual-replace-mode-map : keymap

     This is the map that is active in the minibuffer in Visual Replace
     mode.  You can add your own keybindings to it.

visual-replace-secondary-mode-map : keymap

     This is the map that defines keyboard shortcuts for modifying the
     search mode, such as ‘r’ to toggle regexp mode on or off.  It is
     bound by default in ‘visual-replace-mode-map’ to the shortcut that
     was used to launch Visual Replace, but you can bind it to whatever
     you want, or define custom shortcuts directly in
     ‘visual-replace-mode-map’.

In the example below, ‘C-l’ is bound to secondary mode map and ‘C-r’
toggles the regexp mode, so it is possible to toggle the regexp mode
using either ‘C-l r’ or ‘C-r’.

     (use-package visual-replace
       :defer t
       :bind (("C-c l" . visual-replace)
              :map visual-replace-mode-map
              ("C-r" . visual-replace-toggle-regexp))
       :config
       (define-key visual-replace-mode-map (kbd "C-l")
           visual-replace-secondary-mode-map))


File: visual-replace.info,  Node: Hooks,  Next: Limitations,  Prev: Keymaps,  Up: Usage

2.2.9 Hooks
-----------

visual-replace-minibuffer-mode-hook : hook

     This is a normal hook that is run when entering the visual replace
     mode, so you can set things up just before Visual Replace starts.

visual-replace-defaults-hook : hook

     This is a normal hook that is run when entering the visual replace
     mode with no initial match or replacement, so you can provide some
     default mode without interfering with ‘visual-replace-from-isearch’
     or ‘visual-replace-thing-at-point’.

visual-replace-functions : hook

     Functions in this abnormal hook are called just before executing
     the replacement or just before building the previews.  They are
     passed a struct of type ‘visual-replace-args’, which they can
     modify.  You can use it to customize the behavior of the search or
     modify the regexp language.


File: visual-replace.info,  Node: Limitations,  Prev: Hooks,  Up: Usage

2.2.10 Limitations
------------------

   * Visual Replace avoids executing replacement in the whole buffer
     during preview; it just executes them in the parts of the buffer
     that are currently visible.  This means that the preview can show
     incorrect replacement in some cases, such as when replacement uses
     ‘\#’ directly or within a ‘\,’ In such cases, the preview can be
     wrong but execution will be correct.

     Replacements that call stateful functions in ‘\,’ such as a
     function that increment an internal counter, will be executed too
     many times during preview, with unpredictable results.

     In all other cases, the preview should match what is eventually
     executed.  If that’s not the case, please report an issue.  (*note
     Reporting issues: 19.)

   * If you use ‘visual-replace-apply-one’ to replace single matches,
     ‘\\#’ in the replacement is always 1, because single matches are
     applied separately.


File: visual-replace.info,  Node: API,  Next: Contributing,  Prev: Usage,  Up: Contents

2.3 API
=======

This package provides several different ways of triggering Visual
Replace, from different initial states.  For example, ‘visual-replace’
uses the region to restrict the search, while ‘visual-replace-selection’
uses the region text as match string.  Another example is
‘visual-replace-from-isearch’, which copies the state of a running
search.

Public Functions
................

Public functions are functions without any double dash in their name.
New version of Visual Replace attempt to keep any code calling public
functions backward-compatible, while private function can change, be
renamed, behave differently or disappear from version to version.

Many more variations are possible.  You could imagine a variant of
Visual Replace that uses the current region as match string unless it
contains more tan one line, in which case it’d use it to restrict
search.

In an attempt to support such variations, Visual Replace includes some
public functions you’re encouraged to use to build your own variation.

To add a variation as the one described above, you could write the
following, which modifies the default behavior in one specific case by
overriding the search arguments and scope :

     (defun my-visual-replace ()
       (interactive)
       (let (args scope)
         (when (and (region-active-p)
                    (let ((beg (region-beginning))
                          (end (region-end)))
                      (save-excursion
                        (goto-char beg)
                        (not (search-forward "\n" end 'noerror)))))
           (setq args (visual-replace-make-args
                       :from (buffer-substring-no-properties
                              (region-beginning) (region-end))
                       :to ""))
           (setq scope (visual-replace-make-scope
                       ;; Don't use bounds from the region
                       :bounds nil)))
         (apply #'visual-replace
                (visual-replace-read args scope))))

(visual-replace-read ARGS SCOPE RUN-HOOK) : function

     Build arguments for running ‘visual-replace’ and return them as a
     list, containing search range and modified ‘visual-replace-args’.

     To call ‘visual-replace’ directly after ‘visual-replace-read’, use
     ‘apply’: ‘(apply #'visual-replace (visual-replace-args args
     scope))’

     This function takes two optional arguments, ARGS, created with
     ‘visual-replace-make-args’, and SCOPE, created with
     ‘visual-replace-make-scope’.  If an argument is unspecified or nil,
     the default behavior applies.

     If both ARGS and SCOPE are nil, ‘visual-replace-read’ calls
     ‘visual-replace-defaults-hook’ allow configuring the search using
     hooks unless RUN-HOOK is non-nil.

(visual-replace-make-args KEY-ARGS) : function

     This function builds a struct of type ‘visual-replace-args’.  It
     can take the following key arguments:

        - ‘:from’ to specify the search text.  It must be a regular
          expression in regexp mode.

        - ‘:to’ to specify the replacement text.

          This is often set to the empty string when ‘:from’ is
          specified.

          When ‘:to’ is nil, which is the default, only the search text
          appears in the minibuffer and it it selected.  When this is
          non-nil, even if it is an empty string, the search text is
          followed by a separator arrow, and the replacement text is
          selected.

        - ‘:regexp’ if non-nil, run a regexp search.  ‘:from’ is a
          regular expression and ‘:to’ a replacement string, which might
          include back-references surch as ‘\&’, ‘\N’ or ‘\,’.

        - ‘:query’ if non-nil, query replacements like ‘query-replace’
          does.

        - ‘:word’ if non-nil and ‘:regexp’ is nil, ‘:from’ is searched
          as a word.

        - ‘:case-fold’ if non-nil, search is non case-sensitive and
          replacement are case-aware.  Defaults to ‘case-fold-search’.

        - ‘:backwards’ if non-nil, replace backwards Defaults to nil
          (replace forwards).

        - ‘:lax-ws-non-regexp’ if non-nil, whitespaces in regexp
          searches skip text.  Ignored in non-regexp searches.  Defaults
          to ‘replace-lax-whitespace’.

        - ‘:lax-ws-regexp’ if non-nil, whitespaces in non-regexp
          searches skip text.  Ignored in regexp searches.

(visual-replace-make-scope KEY-ARGS) : function

     This function builds a struct of type ‘visual-replace-scope’ that
     configures the available scopes and sets the current search and
     replace scope.  It can take the following key arguments:

        - ‘:type’ defines the scope ‘visual-replace-read’ starts in.
          Set to ‘'full’ to search the whole buffer, ‘'from-point’ to
          search from given point to the end of the buffer, ‘'region’ to
          search within the given bounds.

          Setting this overrides the default, customizable by
          ‘visual-replace-default-to-full-scope’.  Leave it to nil to
          keep the default behavior.

        - ‘:point’ define the starting point for the search and replace
          in “from point” mode.  Defaults to ‘(point)’.

        - ‘:bounds’ defines the search ranges.  This is in the same
          format as the one returned by ‘region-bounds’: a list of cons
          cells of the form (START .  END). Empty by default.

        - ‘:rectangle’ set it to non-nil if ‘:bounds’ contain multiple
          cons cells that draw a rectangle.  This controls how
          non-contiguous region is drawn.  Nil by default.


File: visual-replace.info,  Node: Contributing,  Prev: API,  Up: Contents

2.4 Contributing
================

* Menu:

* Reporting issues::
* Suggesting features::
* Asking questions::
* Code contributions::
* Documentation contributions::


File: visual-replace.info,  Node: Reporting issues,  Next: Suggesting features,  Up: Contributing

2.4.1 Reporting issues
----------------------

The most useful thing you can do to help is and useful bug reports to
the Issue Tracker(1)

In your report, please discuss what you wanted to happen as well as what
happened.  Also, please include enough information to reproduce the
issue.

Please include:

   - the version of Emacs you’re running, taken, for example, from ‘M-x
     about-emacs’

   - whether you’re running Emacs in a window environment or a terminal

   - the OS you’re running

   - the replacement mode - a copy of what’s shown in the minibuffer.

   - the text you wanted to replace, the replacement text, the
     replacement modes - copying the content of minibuffer will do the
     trick.

     Tip: It’s a great idea to take a screenshot of the Emacs window in
     Visual Replace mode just before executing it, and then another one
     after executing it and attach that to the issue.

   ---------- Footnotes ----------

   (1) https://github.com/szermatt/visual-replace/issues


File: visual-replace.info,  Node: Suggesting features,  Next: Asking questions,  Prev: Reporting issues,  Up: Contributing

2.4.2 Suggesting features
-------------------------

Please create a new discussion(1) or in the Ideas category or add a
feature suggestions to the Issue Tracker(2).

   ---------- Footnotes ----------

   (1) https://github.com/szermatt/visual-replace/discussions

   (2) https://github.com/szermatt/visual-replace/issues


File: visual-replace.info,  Node: Asking questions,  Next: Code contributions,  Prev: Suggesting features,  Up: Contributing

2.4.3 Asking questions
----------------------

Please create a new discussion(1) in the General category with your
question.

   ---------- Footnotes ----------

   (1) https://github.com/szermatt/visual-replace/discussions


File: visual-replace.info,  Node: Code contributions,  Next: Documentation contributions,  Prev: Asking questions,  Up: Contributing

2.4.4 Code contributions
------------------------

To contribute code to the project, open a Pull Request(1).

Before you do that, please make sure the any new features is covered by
tests and that the tests pass.

To run the tests, install and setup eldev(2), then run ‘eldev test’.

Tests can also be run from inside of Emacs, using ‘M-x
ert-run-tests-interactively’ but when you do so, be aware that there
might be unexpected interaction with your Emacs configurations.  The
tests passing reliably when run using ‘eldev test’ is what matters.

Please also make sure your commit message follows Conventional Commits
1.0.0(3), in short, the commit message of new features should start with
“feat: “, fixes with “fix: “, refactorings with “refactor: ” and tests
with “test: “.

   ---------- Footnotes ----------

   (1) https://github.com/szermatt/visual-replace/pulls

   (2) https://github.com/emacs-eldev/eldev

   (3) https://www.conventionalcommits.org/en/v1.0.0/


File: visual-replace.info,  Node: Documentation contributions,  Prev: Code contributions,  Up: Contributing

2.4.5 Documentation contributions
---------------------------------

You don’t need to be a developer to contribute!  Contribution to the
documentation or code comments are very welcome.  Please open a Pull
Request(1) with your proposed modifications.  To follow Conventional
Commits 1.0.0(2), the commit message should start with “docs: “

The documentation is written in reStructuredText.  You’ll need to
install Sphinx(3) to build it:

     python3 -m venv venv
     . venv/bin/activate # or activate.fish on fish
     pip3 install -r docs/requirements.txt

Then run ‘eldev html’ to build the documentation.

   ---------- Footnotes ----------

   (1) https://github.com/szermatt/visual-replace/pulls

   (2) https://www.conventionalcommits.org/en/v1.0.0/

   (3) https://www.sphinx-doc.org


File: visual-replace.info,  Node: Index,  Prev: Contents,  Up: Top

Index
*****

 [index ]
* Menu:

* command; visual-replace:               Commands.             (line  6)
* command; visual-replace-apply-one:     Commands.             (line 29)
* command; visual-replace-apply-one-repeat: Commands.          (line 29)
* command; visual-replace-from-isearch:  Commands.             (line  6)
* command; visual-replace-next-match:    Commands.             (line 29)
* command; visual-replace-prev-match:    Commands.             (line 29)
* command; visual-replace-selected:      Commands.             (line  6)
* command; visual-replace-thing-at-point: Commands.            (line  6)
* command; visual-replace-toggle-backwards: Commands.          (line 29)
* command; visual-replace-toggle-case-fold: Commands.          (line 29)
* command; visual-replace-toggle-lax-ws: Commands.             (line 29)
* command; visual-replace-toggle-query:  Commands.             (line 29)
* command; visual-replace-toggle-regexp: Commands.             (line 29)
* command; visual-replace-toggle-scope:  Commands.             (line 29)
* command; visual-replace-toggle-word:   Commands.             (line 29)
* command; visual-replace-undo:          Commands.             (line 29)
* function; visual-replace-make-args:    API.                  (line  6)
* function; visual-replace-make-scope:   API.                  (line  6)
* function; visual-replace-read:         API.                  (line  6)
* function; visual-replace-yank:         Yank and Pop.         (line  6)
* function; visual-replace-yank-pop:     Yank and Pop.         (line  6)
* hook; visual-replace-functions:        Hooks.                (line  6)
* hook; visual-replace-minibuffer-mode-hook: Hooks.            (line  6)
* variable; visual-replace-default-to-full-scope: Customization.
                                                               (line  6)
* variable; visual-replace-defaults-hook: Customization.       (line  6)
* variable; visual-replace-defaults-hook <1>: Hooks.           (line  6)
* variable; visual-replace-delete-match: Face Customization.   (line  6)
* variable; visual-replace-delete-match-highlight: Face Customization.
                                                               (line  6)
* variable; visual-replace-display-total: Customization.       (line  6)
* variable; visual-replace-first-match:  Customization.        (line  6)
* variable; visual-replace-initial-scope: Customization.       (line  6)
* variable; visual-replace-keep-initial-position: Customization.
                                                               (line  6)
* variable; visual-replace-match:        Face Customization.   (line  6)
* variable; visual-replace-match-count:  Face Customization.   (line  6)
* variable; visual-replace-match-highlight: Face Customization.
                                                               (line  6)
* variable; visual-replace-min-length:   Customization.        (line  6)
* variable; visual-replace-minibuffer-mode-hook: Customization.
                                                               (line  6)
* variable; visual-replace-mode-map:     Keymaps.              (line  6)
* variable; visual-replace-preview:      Customization.        (line  6)
* variable; visual-replace-region:       Face Customization.   (line  6)
* variable; visual-replace-replacement:  Face Customization.   (line  6)
* variable; visual-replace-replacement-highlight: Face Customization.
                                                               (line  6)
* variable; visual-replace-secondary-mode-map: Keymaps.        (line  6)
* variable; visual-replace-separator:    Face Customization.   (line  6)
* variable; visual-replace-transient-map: Commands.            (line 29)



Tag Table:
Node: Top418
Ref: index doc636
Ref: 0636
Ref: Top-Footnote-11774
Node: Comparison with other packages1860
Ref: index comparison-with-other-packages1967
Ref: 11967
Ref: index visual-replace1967
Ref: 21967
Ref: Comparison with other packages-Footnote-12553
Ref: Comparison with other packages-Footnote-22603
Node: Contents2650
Ref: index contents2759
Ref: 32759
Node: Installation2844
Ref: install doc2923
Ref: 42923
Ref: install installation2923
Ref: 52923
Ref: Installation-Footnote-13645
Ref: Installation-Footnote-23689
Ref: Installation-Footnote-33744
Node: Usage3847
Ref: usage doc3938
Ref: 63938
Ref: usage usage3938
Ref: 73938
Node: Calling Visual Replace4153
Ref: usage calling-visual-replace4253
Ref: 84253
Node: Visual Replace Mode5732
Ref: usage visual-replace-mode5853
Ref: 95853
Ref: Visual Replace Mode-Footnote-19475
Node: Yank and Pop9554
Ref: usage yank9672
Ref: b9672
Ref: usage yank-and-pop9672
Ref: c9672
Node: Single replacements10659
Ref: usage single10771
Ref: a10771
Ref: usage single-replacements10771
Ref: d10771
Node: Customization11618
Ref: usage customization11736
Ref: e11736
Ref: usage options11736
Ref: f11736
Node: Face Customization15417
Ref: usage face-customization15524
Ref: 1015524
Ref: usage faces15524
Ref: 1115524
Ref: Face Customization-Footnote-117751
Ref: Face Customization-Footnote-217802
Ref: Face Customization-Footnote-317850
Node: Modus Themes17973
Ref: usage id118066
Ref: 1218066
Node: Ef Themes19355
Ref: usage id219448
Ref: 1319448
Node: Commands21277
Ref: usage commands21378
Ref: 1421378
Ref: usage id321378
Ref: 1521378
Node: Keymaps24759
Ref: usage keymaps24847
Ref: 1624847
Node: Hooks25954
Ref: usage hooks26045
Ref: 1726045
Node: Limitations26911
Ref: usage limitations26986
Ref: 1826986
Node: API27975
Ref: api doc28066
Ref: 1a28066
Ref: api api28066
Ref: 1b28066
Node: Contributing33868
Ref: contrib doc33945
Ref: 1c33945
Ref: contrib contributing33945
Ref: 1d33945
Node: Reporting issues34111
Ref: contrib reporting34212
Ref: 1934212
Ref: contrib reporting-issues34212
Ref: 1e34212
Ref: Reporting issues-Footnote-135176
Node: Suggesting features35234
Ref: contrib discussion35360
Ref: 1f35360
Ref: contrib suggesting-features35360
Ref: 2035360
Ref: Suggesting features-Footnote-135563
Ref: Suggesting features-Footnote-235626
Node: Asking questions35684
Ref: contrib asking-questions35812
Ref: 2135812
Ref: Asking questions-Footnote-135974
Node: Code contributions36037
Ref: contrib code-contributions36173
Ref: 2236173
Ref: Code contributions-Footnote-137015
Ref: Code contributions-Footnote-237072
Ref: Code contributions-Footnote-337117
Node: Documentation contributions37172
Ref: contrib documentation-contributions37283
Ref: 2337283
Ref: contrib eldev37283
Ref: 2437283
Ref: Documentation contributions-Footnote-137943
Ref: Documentation contributions-Footnote-238000
Ref: Documentation contributions-Footnote-338055
Node: Index38090

End Tag Table


Local Variables:
coding: utf-8
End:
